
<!DOCTYPE html>
<html>
<head>
	<style type="text/css">
	body { margin: 0; }
	canvas { width: 100%; height: 100% }
</style>
<script src="./three.min.js"></script>
<script src="./OrbitControls.js"></script>
<script src="./GLTFLoader.js"></script>
<!-- <script type="text/javascript" src="https://azcotic.github.io/threefolder/stats.module.js"></script>
<script type="text/javascript" src="https://azcotic.github.io/threefolder/MathUtils.js"></script> -->
 
<script src="./Detector.js"></script>
<script src="./Stats.js"></script>
<script src="./OrbitControls.js"></script>
<script src="./THREEx.KeyboardState.js"></script>
<script src="./THREEx.FullScreen.js"></script>
<script src="./THREEx.WindowResize.js"></script>
<script src="./Projector.js"></script>
	<title>Dinosaur Game Example</title>
</head>

<body>
	<div id="container"></div>


	<script type="text/javascript">
		//Declaraciones

var mesh, renderer, scene, camera, controls, stats;
var keyboard = new THREEx.KeyboardState();
var modelOut;
var cube;


//Declaraciones para Ray
var raycaster = new THREE.Raycaster();
var mouse = new THREE.Vector2();
var resultado = "";

init();
animate();

function init() {

  // renderer
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // scene

  scene = new THREE.Scene();

  // camera
  camera = new THREE.PerspectiveCamera(105, window.innerWidth / window.innerHeight, 0.1, 2000);
  
  camera.position.set(1, 1, 15);
  
  camera.lookAt(0, 0, 0);
  // controls
  //controls = new THREE.OrbitControls(camera);

  // SUELO
  //var floorTexture = new THREE.ImageUtils.loadTexture( 'checkerboard.jpg' );
  //floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
  //floorTexture.repeat.set( 10, 10 );
  var floorMaterial = new THREE.MeshBasicMaterial( { color: 0xffaa00 } );
  var floorGeometry = new THREE.PlaneGeometry(20, 20, 10, 10);
  var floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.position.y = 1;
  floor.rotation.x = 10;
  floor.position.x= 0;
  floor.position.z = 0;
  scene.add(floor);
  console.log("flor",floor);

  // ambient
  scene.add(new THREE.AmbientLight(0x888888));

  // light
  var light = new THREE.PointLight(0xffffff);
  light.position.set(0,50,1);
  console.log(light.position);
  scene.add(light);

  //Bombillo
  var lightbulb = new THREE.Mesh( 
    new THREE.SphereGeometry(5, 5, 5),
    new THREE.MeshBasicMaterial( { color: 0xffaa00 } )
  );

  lightbulb.position.set(0,50,1);
  console.log(lightbulb.position);
  scene.add( lightbulb );
  

  //projector 
  projector = new THREE.Projector();

  //mesh 
  var darkMaterial = new THREE.MeshBasicMaterial( { color: 0x000088 } );
  var darkMaterialL = new THREE.MeshLambertMaterial( { color: 0x000088 } );
  var darkMaterialP = new THREE.MeshPhongMaterial( { color: 0x000088 } );
  var cubeMat = new THREE.MeshBasicMaterial({
    color: 0x00f00f
  })
  
  var cubeGeom = new THREE.CubeGeometry(3, 3, 3, 1, 1, 1);

  cube = new THREE.Mesh(cubeGeom, darkMaterial);
  cube.position.set(1, 1, 1);
  scene.add(cube);
  cube2 = new THREE.Mesh(cubeGeom, darkMaterialL); 
  cube2.position.set(10, 1, 1);
  scene.add(cube2);
  cube3 = new THREE.Mesh(cubeGeom, darkMaterialP); 
  cube3.position.set(-10, 1, 1);
  scene.add(cube3);
  console.log("Cubo", cube);
  console.log("cubo", cube.position);
render();
  


  

  // STATS
  stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.bottom = '0px';
  stats.domElement.style.zIndex = 100;
  container.appendChild(stats.domElement);

  // axes
  //scene.add( new THREE.AxisHelper( 20 ) );

  var manager = new THREE.LoadingManager();
  manager.onProgress = function(item, loaded, total) {
    console.log(item, loaded, total);
  };


  document.addEventListener('mousedown', onDocumentMouseDown, false);
  window.addEventListener('resize', onWindowResize, false);




  function onWindowResize() {

    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();

    renderer.setSize(window.innerWidth, window.innerHeight);

  }
  var selectedObject = null;

  function onDocumentMouseDown(event) {

    //event.preventDefault();
    //console.log("X:",event.clientX / window.innerWidth * 2 - 1);
    //console.log("Y:",event.clientY / window.innerWidth * 2 + 1);

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    if (!modelOut) return;

    var intersects = raycaster.intersectObject(modelOut, true);
    
    if (intersects.length > 0) {
      // There is intersection with the body
      //console.log(intersects[0].object.name);
      intersects[0].object.material.color.setRGB(25, 0, 0);
      intersects[0].object.traverse((o) => { 	
        if (o.isMesh) {
        	
        }
      });
      //console.log(intersects[ 0 ].instanceId);
    } else {
      // Mouse doesn't intersect the body
      modelOut.traverse((o) => {
        if (o.isMesh) {
        }
      });
    }

  }

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.userPan = false;
  controls.userPanSpeed = 0.0;
  controls.maxDistance = 5000.0;
  controls.maxPolarAngle = Math.PI * 0.395;
  controls.minPolarAngle =Math.PI * 0.395;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0;

}
const DEG2RAD = Math.PI / 180;

function degToRad(degrees) {
  return degrees * MathUtils.DEG2RAD;
}

function render() {

  renderer.render(scene, camera);

}

function update() {


  controls.update();
  stats.update();
}

function animate() {

  requestAnimationFrame(animate);

  controls.update();
  render();
  update();
  renderer.render(scene, camera);

}

	</script>
  </body>
  </html>